#Automated Dice Creator
#Attempted by Lazare -- July 2022
#Based on "Design Your Own Custom Dice for Free | Blender Tutorial | DIY with Cly Ep. 21" by Cly Faker
#https://www.youtube.com/watch?v=nCowrvfOr3Q

#--- TO DO LIST ---
#Do D4, D8, D10, D12, D20, even if it is not optimized
#Optimize dice creation
#Correctly center all numbers one to another and automate the thing
#Do D3, D16, D24, D30 and D3
#Do antiprism dices D4..D12
#Do rhombic dices
#Do bipyramid dices (D5, D7 and D9 possible with double number)
#Do other D24, D48, D64... and more ?
#Do D5 and D7 dices
#Do D2 and D4 rounded cube dices
#Create altered meshes such as rounded, beveled, etc.
#Optimise code for objects, and dice naming

#Import Blender librairies
import bpy
#Import additionnal libraries
import math

#Global variables
_fontFile = "C:\\Windows\\Fonts\\CantaraGotica.ttf"

#Internal global variables
_fontOpen = bpy.data.fonts.load(_fontFile)
_numName = '_Num'
_numbers = ('.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15',
    '16', '17', '18', '19', '20', '30', '40', '50', '60', '70', '80', '90', '00')

#Function: Number Creator
def numberCreator(stringText):
    #Create Text Object
    bpy.ops.object.text_add(align='WORLD', location=(0.0, 0.0, 0.0), rotation=(0.0, 0.0, 0.0), scale=(0.0, 0.0, 0.0))
    #Modify Text Object Name
    meshName = _numName + stringText
    bpy.data.objects['Text'].name = meshName
    #Get curve name for later deletion
    curve = bpy.data.objects[meshName].data
    #Assign Font To Object
    bpy.data.objects[meshName].data.font = _fontOpen
    #Change Text
    bpy.data.objects[meshName].data.body = stringText
    #Modify Text/Curve to Mesh
    bpy.ops.object.convert(target="MESH")
    #Extrude Number
    bpy.ops.object.editmode_toggle()
    bpy.ops.mesh.select_all(action='SELECT')
    bpy.ops.mesh.extrude_region_move(TRANSFORM_OT_translate={"value":(0, 0, 1), "orient_axis_ortho":'X', "orient_type":'NORMAL', "orient_matrix_type":'NORMAL', "constraint_axis":(False, False, True), "mirror":False, "use_proportional_edit":False, "proportional_edit_falloff":'SMOOTH', "proportional_size":1, "use_proportional_connected":False, "use_proportional_projected":False, "snap":False, "snap_target":'CLOSEST', "snap_point":(0, 0, 0), "snap_align":False, "snap_normal":(0, 0, 0), "gpencil_strokes":False, "cursor_transform":False, "texture_space":False, "remove_on_cancel":False, "view2d_edge_pan":False, "release_confirm":False, "use_accurate":False, "use_automerge_and_split":False})
    bpy.ops.object.editmode_toggle()
    #Change Center of Origin
    bpy.ops.object.origin_set(type='ORIGIN_CENTER_OF_VOLUME', center='MEDIAN')
    #Clean the curve
    bpy.data.curves.remove(curve)
    # Rename Mesh    
    bpy.data.objects[meshName].data.name = meshName
    #Unselect Object
    bpy.data.objects[meshName].select_set(False)
    #Return Object Name
    return meshName

#Function: Creation of all Numbers
def generateAllNumbers():
    #For each number on the list, create them
    for x in _numbers:
        numberCreator(x)
        
#Function: Deletion of all numbers
def clearAllNumbers():
    #Delete all meshes linked to numbers
    for x in _numbers:
        bpy.data.meshes.remove(bpy.data.objects[_numName + x].data)

def transformNumber(number, scale, locX, locY, locZ, rotate):
    #Get the number mesh name
    meshName = _numName + number
    #Change Number Dimensions
    bpy.data.objects[meshName].scale = (scale, scale, 1)
    #Change Position
    bpy.data.objects[meshName].location = (locX, locY, locZ)
    #Change Z Rotation
    bpy.data.objects[meshName].rotation_euler = (0, 0, math.radians(rotate))
    
def solidInitializePosition(dice, scale):
    #Center and modify dice
    bpy.data.objects[dice].scale = (scale, scale, scale)
    #Change Position
    bpy.data.objects[dice].location = (0, 0, 0)
    #Change Z Rotation
    bpy.data.objects[dice].rotation_euler = (0, 0, 0)
    #Apply transformations
    bpy.ops.object.transform_apply(location=True, rotation=True, scale=True)
    
#Function: Boolean Operation
def booleanOperationOnObject(objDice, objText):
    #Create the modifier on the Dice
    boolDiff = bpy.data.objects[objDice].modifiers.new(type="BOOLEAN", name="boolDiff")
    #Affect the Text on the modifier
    boolDiff.object = bpy.data.objects[objText]
    #Apply the boolean modification
    bpy.context.view_layer.objects.active = bpy.data.objects[objDice]
    bpy.ops.object.modifier_apply(modifier="boolDiff")
    
#Replace all dices
def replaceAllDices():
    #Change Position of D4
    bpy.data.objects["D4"].hide_set(False)
    bpy.data.objects["D4"].location = (0, -75, 0)
    #Change Position of D6
    bpy.data.objects["D6"].hide_set(False)
    bpy.data.objects["D6"].location = (0, -50, 0)
    #Change Position of D8
    bpy.data.objects["D8"].hide_set(False)
    bpy.data.objects["D8"].location = (0, -25, 0)
    #Change Position of D10
    bpy.data.objects["D10"].hide_set(False)
    bpy.data.objects["D10"].location = (0, 0, 0)
    #Change Position of D10d
    bpy.data.objects["D10d"].hide_set(False)
    bpy.data.objects["D10d"].location = (0, 25, 0)
    #Change Position of D12
    bpy.data.objects["D12"].hide_set(False)
    bpy.data.objects["D12"].location = (0, 50, 0)
    #Change Position of D20
    bpy.data.objects["D20"].hide_set(False)
    bpy.data.objects["D20"].location = (0, 75, 0)
    
#Function: Dice x Triple Rotations
def diceTripleRotations(dice, rotX, rotY):
    #Prepare the inverse rotation
    invRot = rotX * (-1)
    #Do the invert rotation on X
    bpy.data.objects[dice].rotation_euler = (math.radians(invRot), 0, 0)
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Do the Y rotation
    bpy.data.objects[dice].rotation_euler = (0, math.radians(rotY), 0)
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Redo the X rotation
    bpy.data.objects[dice].rotation_euler = (math.radians(rotX), 0, 0)
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    
#Function: Generate a two-coned dice with any number of faces
def generateConedDice(diceName, vert, rad, dep):
    #Generate the first cone and rename it
    bpy.ops.mesh.primitive_cone_add(vertices=vert, radius1=rad, radius2=0, depth=dep, enter_editmode=False, align='WORLD', location=(0, 0, 0), rotation=(0, 0, 0), scale=(1, 1, 1))
    bpy.data.objects['Cone'].name = diceName
    bpy.data.objects[diceName].data.name = diceName
    #Generate a second cone, the same, and rotate it by 180Â° on X
    bpy.ops.mesh.primitive_cone_add(vertices=vert, radius1=rad, radius2=0, depth=dep, enter_editmode=False, align='WORLD', location=(0, 0, 0), rotation=(0, 0, 0), scale=(1, 1, 1))
    bpy.data.objects['Cone'].rotation_euler = (math.radians(180), 0, 0)
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Create a intersect boolean operation  
    intersectDiff = bpy.data.objects[diceName].modifiers.new(type="BOOLEAN", name="intersectDiff")
    #Affect the cone on the modifier
    intersectDiff.object = bpy.data.objects["Cone"]
    #Change the boolean method to INTERSECT
    intersectDiff.operation = "INTERSECT"
    #Apply the boolean modification
    bpy.context.view_layer.objects.active = bpy.data.objects[diceName]
    bpy.ops.object.modifier_apply(modifier="intersectDiff")
    #Delete the remaining cone
    bpy.data.meshes.remove(bpy.data.objects["Cone"].data)
    #Select the Bipyramidal dice
    bpy.data.objects[diceName].select_set(True)
    
#Function: Dice 4 Generator
def dice4Generator():
    #Number order
    numOrd = (4, 3, 2, 1)
    #Transformations pre-calculations
    transformationA = (0, 0, math.radians(120))
    transformationB = (0, 0, math.radians(-120))
    #Transformations order
    rotations = (transformationA, transformationB, transformationB, (0, 0, 0))
    #Generate Tetrahedron
    bpy.ops.mesh.primitive_solid_add(source='4')
    #Rename Tetrahedron
    bpy.data.objects['Solid'].name = "D4"
    bpy.data.objects['D4'].data.name = "D4"
    #Center and position dice
    solidInitializePosition("D4", 15)
    #Initial rotation
    bpy.data.objects['D4'].rotation_euler = (0, 0, math.radians(-30))
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    bpy.data.objects['D4'].rotation_euler = (0, math.radians(180), 0)
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Create Rotations & Boolean operations
    for i in range(4):
        #Modify number position
        transformNumber(str(numOrd[i]), 10, 0, 6.5, 5, 0)
        for j in range(3):
            #Boolean modifier for 1st number
            booleanOperationOnObject('D4', _numName + str(numOrd[i]))
            #Serie of various rotations only for the first and second rotatons
            if (j < 2):
                diceTripleRotations('D4', 19.47, 120)
        #Apply new rotations to dice
        if (numOrd[i] == 2):
            diceTripleRotations('D4', 19.47, 120)
        bpy.data.objects['D4'].rotation_euler = rotations[i]
        bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Apply last rotation for 1-face upward
    bpy.data.objects['D4'].rotation_euler = (math.radians(70.53), 0, 0)
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Hide the D4
    bpy.data.objects['D4'].hide_set(True)        
        
#Function: Dice 6 Generator
def dice6Generator():
    #Number order
    numOrd = (6, 2, 4, 3, 1, 5)
    #Transformations pre-calculations
    transformationA = (0, math.radians(-90), math.radians(90))
    transformationB = (math.radians(180), 0, 0)
    transformationC = (0, math.radians(90), math.radians(-90))
    #Transformations order
    rotations = ((0, 0, 0), transformationA, transformationA, transformationB, transformationC, transformationC)
    #Cube generation
    bpy.ops.mesh.primitive_cube_add(location=(0.0, 0.0, 0.0), rotation=(0.0, 0.0, 0.0), scale=(8, 8, 8))
    #Modify Cube name to D6
    bpy.data.objects['Cube'].name = "D6"
    bpy.data.objects['D6'].data.name = "D6"
    #Rotation & Boolean operation between Dice and Number for all faces
    for i in range(6):
        #Modify Number Position
        transformNumber(str(numOrd[i]), 16, 0, 0, 8, 0)
        #Apply rotations to dice
        bpy.data.objects['D6'].rotation_euler = rotations[i]
        bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
        #Apply boolean operation on dice
        booleanOperationOnObject('D6', _numName + str(numOrd[i]))
    #Apply last rotation for 6-face upward
    bpy.data.objects['D6'].rotation_euler = (math.radians(90), 0, 0)
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Hide the D6
    bpy.data.objects['D6'].hide_set(True)
    
#Function: Dice 8 Generator
def dice8Generator():
    #Number order
    numOrd = (8, 2, 6, 4, 5, 3, 7, 1)
    #Generate Tetrahedron
    bpy.ops.mesh.primitive_solid_add(source='8')
    #Rename Tetrahedron
    bpy.data.objects['Solid'].name = "D8"
    bpy.data.objects['D8'].data.name = "D8"
    #Before any resize, rotate the dice
    bpy.data.objects['D8'].rotation_euler = (0, math.radians(45), 0)
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    bpy.data.objects['D8'].rotation_euler = (math.radians(35.265), 0, 0)
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Center and position dice
    solidInitializePosition("D8", 15)
    #Rotation & Boolean operation between Dice and Number for all faces
    for i in range(8):
        #Modify Number Position
        transformNumber(str(numOrd[i]), 13, 0, 1, 8.66, 0)
        #Apply boolean operation on dice
        booleanOperationOnObject('D8', _numName + str(numOrd[i]))
        #Rotate the dice
        if((i % 4) == 3):
            bpy.data.objects['D8'].rotation_euler = (math.radians(180), 0, 0)
            bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
        else:
            diceTripleRotations('D8', 35.265, -90)
    #Hide the D8
    bpy.data.objects['D8'].hide_set(True)            
            
#Function: Dice 10 Generator
def dice10UnitGenerator():
    #Number order
    numOrd = (6, 4, 8, 2, 0, 1, 9, 3, 7, 5)
    #Generate the D10 solid base
    generateConedDice("D10", 5, 2, 2.25)
    #Rotate the dice for a better scaling
    bpy.data.objects['D10'].rotation_euler = (math.radians(-54.3), 0, 0)
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Initialize position, rotation and scale
    solidInitializePosition("D10", 13)
    #Prepare the dot/underscore sign position
    transformNumber('.', 12, 0, -5.4, 8.55, 0)
    #Rotation & Boolean operation between Dice and Number for all faces
    for i in range(10):
        #Modify Number Position
        transformNumber(str(numOrd[i]), 12, 0, 0, 8.55, 0)
        #Apply boolean operation on dice
        booleanOperationOnObject('D10', _numName + str(numOrd[i]))
        #If there is a 6 or a 9 face, apply the dot/underscore on the bottom
        if((numOrd[i] == 6) or (numOrd[i] == 9)):
            booleanOperationOnObject('D10', _numName + '.')
        #Rotate the dice
        if((i % 5) == 4):
            bpy.data.objects['D10'].rotation_euler = (math.radians(180), 0, 0)
            bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
        else:
            diceTripleRotations('D10', 35.7, -72)
    #Hide the D10
    bpy.data.objects['D10'].hide_set(True)  
    
#Function: Dice 10 Generator
def dice10DecimalGenerator():
    #Number order --There is a problem with 00. I have to do this trick for now...
    numOrd = ('60', '40', '80', '20', '00', '10', '90', '30', '70', '50')
    #Generate the D10 solid base
    generateConedDice("D10d", 5, 2, 2.25)
    #Rotate the dice for a better scaling
    bpy.data.objects['D10d'].rotation_euler = (math.radians(-54.3), 0, 0)
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Initialize position, rotation and scale
    solidInitializePosition("D10d", 13)
    #Rotation & Boolean operation between Dice and Number for all faces
    for i in range(10):
        #Modify Number Position
        transformNumber(str(numOrd[i]), 9, 0, -1.55, 8.55, 90)
        #Apply boolean operation on dice
        booleanOperationOnObject('D10d', _numName + numOrd[i])
        #Rotate the dice
        if((i % 5) == 4):
            bpy.data.objects['D10d'].rotation_euler = (math.radians(180), 0, 0)
            bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
        else:
            diceTripleRotations('D10d', 35.7, -72)
    #Hide the D10
    bpy.data.objects['D10d'].hide_set(True)      
    
#Function: Dice 12 Generator
def dice12Generator():
    #Number order
    numOrd = (12, 8, 6, 4, 2, 10, 1, 3, 11, 9, 7, 5)
    #Transformations pre-calculations
    transformationA = (0, 0, math.radians(36))
    transformationB = (0, 0, math.radians(72))
    #Transformations order
    rotations = (transformationA, transformationB, transformationB, transformationB, transformationB, transformationA)
    #Generate Dodecahedron
    bpy.ops.mesh.primitive_solid_add(source='12')
    #Rename Dodecahedron
    bpy.data.objects['Solid'].name = "D12"
    bpy.data.objects['D12'].data.name = "D12"
    #Rotate the dice for a better scaling
    bpy.data.objects['D12'].rotation_euler = (math.radians(-58.285), 0, 0)
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Initialize position, rotation and scale
    solidInitializePosition("D12", 12)
    #Prepare the dot/underscore sign position
    transformNumber('.', 10, 0, -4.5, 9.54, 0)
    #Rotation & Boolean operation between Dice and Number for all faces
    for i in range(12):
        #Do a rotation if the numbers are not 12 & 1
        if ((i % 6) > 0):
            bpy.data.objects['D12'].rotation_euler = (math.radians(63.43), 0, 0)
        #Modify Number Position
        transformNumber(str(numOrd[i]), 10, 0, 0, 9.54, 0)
        #Apply boolean operation on dice
        booleanOperationOnObject('D12', _numName + str(numOrd[i]))
        #If there is a 6 or a 9 face, apply the dot/underscore on the bottom
        if((numOrd[i] == 6) or (numOrd[i] == 9)):
            booleanOperationOnObject('D12', _numName + '.')
        #Rotate the dice around 12 & 1
        bpy.data.objects['D12'].rotation_euler = rotations[(i % 6)]
        bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
        #After finalizing half of the dice operations, rotate it.
        if((i % 6) == 5):
            bpy.data.objects['D12'].rotation_euler = (math.radians(180), 0, 0)
            bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Hide the D12
    bpy.data.objects['D12'].hide_set(True)  
    
#Function: Dice 20 Generator
def dice20Generator():    
    #Number order
    numOrd = (20, 14, 6, 4, 8, 10, 16, 2, 18, 12, 1, 19, 9, 3, 13, 5, 11, 7, 17, 15)
    #Transformations pre-calculations
    transformationX1 = (math.radians(41.81), 0, 0)
    transformationX2 = (math.radians(-41.81), 0, 0)
    transformationX3 = (math.radians(180), 0, 0)
    transformationZ1 = (0, 0, math.radians(60))
    transformationZ2 = (0, 0, math.radians(120))
    transformationZ3 = (0, 0, math.radians(-120))
    #Transformations order
    rotations = ((transformationZ1, transformationX1),
        (transformationZ1, transformationX1),
        (transformationX2, transformationZ3, transformationX1),
        (transformationX2, transformationZ1, transformationX2, transformationZ2, transformationX1),
        (transformationZ1, transformationX1),
        (transformationX2, transformationZ3, transformationX1),
        (transformationX2, transformationZ1, transformationX2, transformationZ2, transformationX1),
        (transformationZ1, transformationX1),
        (transformationX2, transformationZ3, transformationX1),
        (transformationX2, transformationZ1, transformationX2, transformationZ1, transformationX3),
        (transformationZ1, transformationX1),
        (transformationZ1, transformationX1),
        (transformationX2, transformationZ3, transformationX1),
        (transformationX2, transformationZ1, transformationX2, transformationZ2, transformationX1),
        (transformationZ1, transformationX1),
        (transformationX2, transformationZ3, transformationX1),
        (transformationX2, transformationZ1, transformationX2, transformationZ2, transformationX1),
        (transformationZ1, transformationX1),
        (transformationX2, transformationZ3, transformationX1),
        (transformationX2, transformationZ1, transformationX2, transformationZ1, transformationX3))
    #Generate Icosahedron
    bpy.ops.mesh.primitive_solid_add(source='20')
    #Rename Dodecahedron
    bpy.data.objects['Solid'].name = "D20"
    bpy.data.objects['D20'].data.name = "D20"
    #Rotate the dice for a better scaling
    bpy.data.objects['D20'].rotation_euler = (math.radians(20.905), 0, 0)
    bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Initialize position, rotation and scale
    solidInitializePosition("D20", 14)
    #Prepare the dot/underscore sign position
    transformNumber('.', 7, 0, -3.15, 11.125, 0)
    #Rotation & Boolean operation between Dice and Number for all faces
    for i in range(20):
        #Modify Number Position
        transformNumber(str(numOrd[i]), 7, 0, 0, 11.125, 0)
        #Apply boolean operation on dice
        booleanOperationOnObject('D20', _numName + str(numOrd[i]))
        #If there is a 6 or a 9 face, apply the dot/underscore on the bottom
        if((numOrd[i] == 6) or (numOrd[i] == 9)):
            booleanOperationOnObject('D20', _numName + '.')
        #Sequence the rotations and boolean for half a dice
        for sequence in rotations[i]:
            bpy.data.objects['D20'].rotation_euler = sequence
            bpy.ops.object.transform_apply(location=False, rotation=True, scale=False)
    #Hide the D20
    bpy.data.objects['D20'].hide_set(True)  
    
#Main function    
def main():
    #Generate all numbers
    generateAllNumbers()
    #6-sided dice generator
    dice6Generator()
    dice4Generator()
    dice8Generator()
    dice10UnitGenerator()
    dice10DecimalGenerator()
    dice12Generator()
    dice20Generator()
    #Delete all numbers
    clearAllNumbers()
    #Clean the font used
    bpy.data.fonts.remove(_fontOpen)
    #Replace all dices of a better view
    replaceAllDices()
    
if __name__ == "__main__":
    main()
#Success !!!